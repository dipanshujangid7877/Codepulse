'use strict';

var React = require('react');
var sx = require('../sx.js');
var useProvidedRefOrCreate = require('../hooks/useProvidedRefOrCreate.js');
var useOnEscapePress = require('../hooks/useOnEscapePress.js');
require('@primer/behaviors/utils');
var behaviors = require('@primer/behaviors');
var useId = require('../hooks/useId.js');
var invariant = require('../utils/invariant.js');
var warning = require('../utils/warning.js');
var styled = require('styled-components');
var constants = require('../constants.js');
var popoverFn = require('../node_modules/@oddbird/popover-polyfill/dist/popover-fn.js');
var toggleStyledComponent = require('../internal/utils/toggleStyledComponent.js');
var clsx = require('clsx');
var Tooltip_module = require('./Tooltip.module.css.js');
require('../FeatureFlags/FeatureFlags.js');
var useFeatureFlag = require('../FeatureFlags/useFeatureFlag.js');
require('../FeatureFlags/DefaultFeatureFlags.js');
var KeybindingHint = require('../KeybindingHint/KeybindingHint.js');
var _VisuallyHidden = require('../_VisuallyHidden.js');
var useSafeTimeout = require('../hooks/useSafeTimeout.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var styled__default = /*#__PURE__*/_interopDefault(styled);

function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const CSS_MODULE_FEATURE_FLAG = 'primer_react_css_modules_staff';
const animationStyles = `
  animation-name: tooltip-appear;
  animation-duration: 0.1s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-in;
  animation-delay: 0s;
`;
const StyledTooltip = toggleStyledComponent.toggleStyledComponent(CSS_MODULE_FEATURE_FLAG, 'span', styled__default.default.span.withConfig({
  displayName: "Tooltip__StyledTooltip",
  componentId: "sc-e45c7z-0"
})(["display:none;&[popover]{position:absolute;padding:0.5em 0.75em;width:max-content;margin:auto;clip:auto;white-space:normal;font:normal normal 11px/1.5 ", ";-webkit-font-smoothing:subpixel-antialiased;color:var(--tooltip-fgColor,", ");text-align:center;word-wrap:break-word;background:var(--tooltip-bgColor,", ");border-radius:", ";border:0;opacity:0;max-width:250px;inset:auto;overflow:visible;}&[popover]:popover-open{display:block;}&[popover].\\:popover-open{display:block;}@media (forced-colors:active){outline:1px solid transparent;}&::after{position:absolute;display:block;right:0;left:0;height:var(--overlay-offset,0.25rem);content:'';}&[data-direction='n']::after,&[data-direction='ne']::after,&[data-direction='nw']::after{top:100%;}&[data-direction='s']::after,&[data-direction='se']::after,&[data-direction='sw']::after{bottom:100%;}&[data-direction='w']::after{position:absolute;display:block;height:100%;width:8px;content:'';bottom:0;left:100%;}&[data-direction='e']::after{position:absolute;display:block;height:100%;width:8px;content:'';bottom:0;right:100%;margin-left:-8px;}@keyframes tooltip-appear{from{opacity:0;}to{opacity:1;}}&:popover-open,&:popover-open::before{", "}&.\\:popover-open,&.\\:popover-open::before{", "}", ";"], constants.get('fonts.normal'), constants.get('colors.fg.onEmphasis'), constants.get('colors.neutral.emphasisPlus'), constants.get('radii.2'), animationStyles, animationStyles, sx.default));
// map tooltip direction to anchoredPosition props
const directionToPosition = {
  nw: {
    side: 'outside-top',
    align: 'end'
  },
  n: {
    side: 'outside-top',
    align: 'center'
  },
  ne: {
    side: 'outside-top',
    align: 'start'
  },
  e: {
    side: 'outside-right',
    align: 'center'
  },
  se: {
    side: 'outside-bottom',
    align: 'start'
  },
  s: {
    side: 'outside-bottom',
    align: 'center'
  },
  sw: {
    side: 'outside-bottom',
    align: 'end'
  },
  w: {
    side: 'outside-left',
    align: 'center'
  }
};

// map anchoredPosition props to tooltip direction
const positionToDirection = {
  'outside-top-end': 'nw',
  'outside-top-center': 'n',
  'outside-top-start': 'ne',
  'outside-right-center': 'e',
  'outside-bottom-start': 'se',
  'outside-bottom-center': 's',
  'outside-bottom-end': 'sw',
  'outside-left-center': 'w'
};

// The list is from GitHub's custom-axe-rules https://github.com/github/github/blob/master/app/assets/modules/github/axe-custom-rules.ts#L3
const interactiveElements = ['a[href]', 'button:not([disabled])', 'summary', 'select', 'input:not([type=hidden])', 'textarea'];
const isInteractive = element => {
  return interactiveElements.some(selector => element.matches(selector)) || element.hasAttribute('role') && element.getAttribute('role') === 'button';
};
const TooltipContext = /*#__PURE__*/React__default.default.createContext({});
const Tooltip = /*#__PURE__*/React__default.default.forwardRef(({
  direction = 's',
  text,
  type = 'description',
  children,
  id,
  className,
  keybindingHint,
  ...rest
}, forwardedRef) => {
  const tooltipId = useId.useId(id);
  const child = React.Children.only(children);
  const triggerRef = useProvidedRefOrCreate.useProvidedRefOrCreate(forwardedRef);
  const tooltipElRef = React.useRef(null);
  const enabled = useFeatureFlag.useFeatureFlag(CSS_MODULE_FEATURE_FLAG);
  const [calculatedDirection, setCalculatedDirection] = React.useState(direction);
  const [isPopoverOpen, setIsPopoverOpen] = React.useState(false);
  const timeoutRef = React__default.default.useRef(null);
  const {
    safeSetTimeout,
    safeClearTimeout
  } = useSafeTimeout();
  const openTooltip = () => {
    try {
      if (tooltipElRef.current && triggerRef.current && tooltipElRef.current.hasAttribute('popover') && !tooltipElRef.current.matches(':popover-open')) {
        const tooltip = tooltipElRef.current;
        const trigger = triggerRef.current;
        tooltip.showPopover();
        setIsPopoverOpen(true);
        /*
         * TOOLTIP POSITIONING
         */
        const settings = {
          side: directionToPosition[direction].side,
          align: directionToPosition[direction].align
        };
        const {
          top,
          left,
          anchorAlign,
          anchorSide
        } = behaviors.getAnchoredPosition(tooltip, trigger, settings);
        // This is required to make sure the popover is positioned correctly i.e. when there is not enough space on the specified direction, we set a new direction to position the ::after
        const calculatedDirection = positionToDirection[`${anchorSide}-${anchorAlign}`];
        setCalculatedDirection(calculatedDirection);
        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
      }
    } catch (error) {
      // older browsers don't support the :popover-open selector and will throw, even though we use a polyfill
      // see https://github.com/github/issues/issues/12468
      if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string' && error.message.includes('not a valid selector')) ; else {
        throw error;
      }
    }
  };
  const closeTooltip = () => {
    try {
      if (tooltipElRef.current && triggerRef.current && tooltipElRef.current.hasAttribute('popover') && tooltipElRef.current.matches(':popover-open')) {
        tooltipElRef.current.hidePopover();
        setIsPopoverOpen(false);
      } else {
        setIsPopoverOpen(false);
      }
    } catch (error) {
      // older browsers don't support the :popover-open selector and will throw, even though we use a polyfill
      // see https://github.com/github/issues/issues/12468
      if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string' && error.message.includes('not a valid selector')) ; else {
        throw error;
      }
    }
  };

  // context value
  const value = React.useMemo(() => ({
    tooltipId
  }), [tooltipId]);
  React.useEffect(() => {
    if (!tooltipElRef.current || !triggerRef.current) return;
    /*
     * ACCESSIBILITY CHECKS
     */
    // Has trigger element or any of its children interactive elements?
    const isTriggerInteractive = isInteractive(triggerRef.current);
    const triggerChildren = triggerRef.current.childNodes;
    // two levels deep
    const hasInteractiveDescendant = Array.from(triggerChildren).some(child => {
      return child instanceof HTMLElement && isInteractive(child) || Array.from(child.childNodes).some(grandChild => grandChild instanceof HTMLElement && isInteractive(grandChild));
    });
    !(isTriggerInteractive || hasInteractiveDescendant) ? process.env.NODE_ENV !== "production" ? invariant.invariant(false, 'The `Tooltip` component expects a single React element that contains interactive content. Consider using a `<button>` or equivalent interactive element instead.') : invariant.invariant(false) : undefined;
    // If the tooltip is used for labelling the interactive element, the trigger element or any of its children should not have aria-label
    if (type === 'label') {
      const hasAriaLabel = triggerRef.current.hasAttribute('aria-label');
      const hasAriaLabelInChildren = Array.from(triggerRef.current.childNodes).some(child => child instanceof HTMLElement && child.hasAttribute('aria-label'));
      process.env.NODE_ENV !== "production" ? warning.warning(hasAriaLabel || hasAriaLabelInChildren, 'The label type `Tooltip` is going to be used here to label the trigger element. Please remove the aria-label from the trigger element.') : undefined;
    }

    // SSR safe polyfill apply
    if (typeof window !== 'undefined') {
      if (!popoverFn.isSupported()) {
        popoverFn.apply();
      }
    }
    const tooltip = tooltipElRef.current;
    tooltip.setAttribute('popover', 'auto');
  }, [tooltipElRef, triggerRef, direction, type]);
  useOnEscapePress.useOnEscapePress(event => {
    if (isPopoverOpen) {
      event.stopImmediatePropagation();
      event.preventDefault();
      closeTooltip();
    }
  }, [isPopoverOpen]);
  return /*#__PURE__*/React__default.default.createElement(TooltipContext.Provider, {
    value: value
  }, /*#__PURE__*/React__default.default.createElement(React__default.default.Fragment, null, /*#__PURE__*/React__default.default.isValidElement(child) && /*#__PURE__*/React__default.default.cloneElement(child, {
    ref: triggerRef,
    // If it is a type description, we use tooltip to describe the trigger
    'aria-describedby': type === 'description' ? tooltipId : child.props['aria-describedby'],
    // If it is a label type, we use tooltip to label the trigger
    'aria-labelledby': type === 'label' ? tooltipId : child.props['aria-labelledby'],
    onBlur: event => {
      var _child$props$onBlur, _child$props;
      closeTooltip();
      (_child$props$onBlur = (_child$props = child.props).onBlur) === null || _child$props$onBlur === undefined ? undefined : _child$props$onBlur.call(_child$props, event);
    },
    onFocus: event => {
      var _child$props$onFocus, _child$props2;
      // only show tooltip on :focus-visible, not on :focus
      try {
        if (!event.target.matches(':focus-visible')) return;
      } catch (error) {
        // jsdom (jest) does not support `:focus-visible` yet and would throw an error
        // https://github.com/jsdom/jsdom/issues/3426
      }
      openTooltip();
      (_child$props$onFocus = (_child$props2 = child.props).onFocus) === null || _child$props$onFocus === undefined ? undefined : _child$props$onFocus.call(_child$props2, event);
    },
    onMouseEnter: event => {
      // show tooltip after mosue has been hovering for at least 50ms
      // (prevent showing tooltip when mouse is just passing through)
      timeoutRef.current = safeSetTimeout(() => {
        var _child$props$onMouseE, _child$props3;
        openTooltip();
        (_child$props$onMouseE = (_child$props3 = child.props).onMouseEnter) === null || _child$props$onMouseE === undefined ? undefined : _child$props$onMouseE.call(_child$props3, event);
      }, 50);
    },
    onMouseLeave: event => {
      var _child$props$onMouseL, _child$props4;
      if (timeoutRef.current) {
        safeClearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
      closeTooltip();
      (_child$props$onMouseL = (_child$props4 = child.props).onMouseLeave) === null || _child$props$onMouseL === undefined ? undefined : _child$props$onMouseL.call(_child$props4, event);
    }
  }), /*#__PURE__*/React__default.default.createElement(StyledTooltip, _extends({
    className: clsx.clsx(className, {
      [Tooltip_module.Tooltip]: enabled
    }),
    ref: tooltipElRef,
    "data-direction": calculatedDirection
  }, rest, {
    // Only need tooltip role if the tooltip is a description for supplementary information
    role: type === 'description' ? 'tooltip' : undefined
    // stop AT from announcing the tooltip twice: when it is a label type it will be announced with "aria-labelledby",when it is a description type it will be announced with "aria-describedby"
    ,
    "aria-hidden": true,
    id: tooltipId
    // mouse leave and enter on the tooltip itself is needed to keep the tooltip open when the mouse is over the tooltip
    ,
    onMouseEnter: openTooltip,
    onMouseLeave: closeTooltip
  }), text, keybindingHint && /*#__PURE__*/React__default.default.createElement("span", {
    className: clsx.clsx(Tooltip_module.keybindingHintContainer, text && Tooltip_module.hasTextBefore)
  }, /*#__PURE__*/React__default.default.createElement(_VisuallyHidden, null, "("), /*#__PURE__*/React__default.default.createElement(KeybindingHint.KeybindingHint, {
    keys: keybindingHint,
    format: "condensed",
    variant: "onEmphasis",
    size: "small"
  }), /*#__PURE__*/React__default.default.createElement(_VisuallyHidden, null, ")")))));
});

exports.Tooltip = Tooltip;
exports.TooltipContext = TooltipContext;
